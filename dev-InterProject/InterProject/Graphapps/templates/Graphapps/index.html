<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>计算机专业知识图谱</title>
    <!-- 引入D3.js可视化库 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- 引入Bootstrap样式库 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        .container-fluid {
            padding: 0;
        }
        .sidebar {
            background-color: #f0f0f0;
            padding: 15px;
            height: 100vh;
            overflow-y: auto;
        }
        .main-content {
            padding: 0;
            height: 100vh;
            position: relative;
        }
        #graph-container {
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
        }
        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
        }
        .node-label {
            font-size: 12px;
            pointer-events: none;
        }
        .link-label {
            font-size: 12px;
            pointer-events: none;
            fill: #333;
            /* 添加背景使标签更加醒目 */
            background: white;
            font-weight: 500;
        }
        /* 新增关系标签的背景和边框样式 */
        .link-label-bg {
            fill: rgba(255, 255, 255, 0.9);
            rx: 4;
            ry: 4;
            stroke: #ddd;
            stroke-width: 0.5;
        }
        .search-box {
            margin-bottom: 15px;
        }
        .card {
            margin-bottom: 15px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .properties-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 100;
            max-height: 80%;
            overflow-y: auto;
            display: none;
        }
        .query-box {
            margin-bottom: 15px;
        }
        .preset-query {
            margin-bottom: 5px;
            text-align: left;
            padding: 8px;
        }
        .statistics {
            margin-top: 20px;
        }
        /* 新增 */
        .controls-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 100;
        }
        .node.highlighted {
            stroke: #FF4500;
            stroke-width: 3px;
        }
        .node.fixed {
            stroke: #444;
            stroke-width: 2px;
        }
        .node-label.highlighted {
            font-weight: bold;
            fill: #FF4500;
        }
        #node-limit-control {
            margin-top: 10px;
        }
        .slider-container {
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row">
            <!-- 左侧边栏：查询工具 -->
            <div class="col-md-3 sidebar">
                <h3 class="mb-4">计算机专业知识图谱</h3>

                <!-- 查询框 -->
                <div class="query-box">
                    <div class="input-group mb-3">
                        <input type="text" id="query-input" class="form-control" placeholder="输入查询语句...">
                        <button class="btn btn-primary" id="query-btn">查询</button>
                    </div>
                    <div class="form-text mb-2">支持自然语言查询，例如："查找与算法相关的知识点"</div>
        </div>

                <!-- 预设查询按钮组 -->
                <div class="card">
                    <div class="card-header">
                        常用查询
                    </div>
                    <div class="card-body">
                        <button class="btn btn-outline-secondary preset-query" data-query="显示所有知识点">显示所有知识点</button>
                        <button class="btn btn-outline-secondary preset-query" data-query="显示所有课程">显示所有课程</button>
                        <button class="btn btn-outline-secondary preset-query" data-query="显示整个知识图谱">显示整个知识图谱</button>
                        <button class="btn btn-outline-secondary preset-query" data-query="search 算法">搜索"算法"</button>
                        <button class="btn btn-outline-secondary preset-query" data-query="search 人工智能">搜索"人工智能"</button>
                        <button class="btn btn-outline-secondary preset-query" data-query="search 数据结构">搜索"数据结构"</button>
                    </div>
        </div>

                <!-- 统计信息 -->
                <div class="card statistics">
                    <div class="card-header">
                        知识图谱统计
            </div>
                    <div class="card-body">
                        <div id="statistics-content">
                            <p>实体数量：<span id="entity-count">0</span></p>
                            <p>关系数量：<span id="relation-count">0</span></p>
        </div>
                    </div>
                </div>

                <!-- 添加管理面板按钮 -->
                <div class="card">
                    <div class="card-header">
                        管理选项
                    </div>
                    <div class="card-body">
                        <a href="/admin" class="btn btn-primary">进入管理面板</a>
        </div>
    </div>

                <!-- 分类信息 -->
                <div class="card">
                    <div class="card-header">
                        实体类型
                    </div>
                    <div class="card-body">
                        <div id="entity-types">
                            <!-- 实体类型将动态加载 -->
                        </div>
                    </div>
                </div>

                <!-- 关系类型 -->
                <div class="card">
                    <div class="card-header">
                        关系类型
                    </div>
                    <div class="card-body">
                        <div id="relation-types">
                            <!-- 关系类型将动态加载 -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- 右侧主要内容：图谱可视化 -->
            <div class="col-md-9 main-content">
                <div id="graph-container"></div>
                <div class="controls-panel">
                    <button id="pause-btn" class="btn btn-sm btn-outline-primary">暂停</button>
                    <button id="stabilize-btn" class="btn btn-sm btn-outline-secondary">稳定布局</button>
                    <button id="reset-btn" class="btn btn-sm btn-outline-danger">重置</button>
                    <div id="node-limit-control">
                        <label for="node-limit-slider" class="form-label">节点限制: <span id="node-limit-value">100</span></label>
                        <div class="slider-container">
                            <input type="range" class="form-range" id="node-limit-slider" min="10" max="500" value="100">
                        </div>
                    </div>
                    <div class="form-check form-switch mt-2">
                        <input class="form-check-input" type="checkbox" id="show-labels-switch" checked>
                        <label class="form-check-label" for="show-labels-switch">显示实体标签</label>
                    </div>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-relation-labels-switch" checked>
                        <label class="form-check-label" for="show-relation-labels-switch">显示关系标签</label>
                    </div>
                </div>
                <div id="loading" class="loading" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">加载中...</span>
                    </div>
                    <p class="mt-2">加载中...</p>
                </div>
                <div id="properties-panel" class="properties-panel">
                    <h5 id="properties-title">属性详情</h5>
                    <button type="button" class="btn-close position-absolute top-0 end-0 m-2" aria-label="Close" id="close-properties"></button>
                    <div id="properties-content"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 引入Bootstrap JavaScript库 -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 图谱可视化和交互代码
        document.addEventListener('DOMContentLoaded', function() {
            // 检测运行环境并设置API基础URL
            const isFileProtocol = window.location.protocol === 'file:';
            const API_BASE_URL = isFileProtocol ? 'http://127.0.0.1:8000' : '';

            if (isFileProtocol) {
                console.log('检测到文件协议，使用本地API服务器: ' + API_BASE_URL);
                // 显示提示信息
                const alertDiv = document.createElement('div');
                alertDiv.className = 'alert alert-info alert-dismissible fade show';
                alertDiv.innerHTML = `
                    <strong>提示:</strong> 检测到您直接打开了HTML文件。请确保Django后端服务器正在运行 (http://127.0.0.1:8000)
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                document.body.insertBefore(alertDiv, document.body.firstChild);
            }

            // 定义全局变量
            let simulation;
            let svg;
            let g;
            let nodes = [];
            let links = [];
            let nodeElements;
            let linkElements;
            let nodeLabels;
            let linkLabels;
            let originalData = null;
            let isPaused = false;
            let nodeLimit = 100;
            let showLabels = true;
            let showRelationLabels = true;
            let zoom; // 添加缩放控制变量

            // 添加关系类型的英文到中文的映射表
            const relationTypeMap = {
                "RELATED_TO": "相关于",
                "PART_OF": "属于",
                "PREREQUISITE": "先决条件",
                "INCLUDES": "包含",
                "FOLLOWS": "跟随",
                "SIMILAR_TO": "类似于",
                "DEPENDS_ON": "依赖于",
                "APPLIES_TO": "应用于",
                "USED_IN": "用于",
                "SUBSET_OF": "子集",
                "INSTANCE_OF": "实例",
                "DEFINED_BY": "定义",
                "IMPLEMENTED_IN": "实现于",
                "CONTAINS": "包含"
            };

            // 转换关系类型为中文函数
            function translateRelationType(type) {
                // 如果有多个关系类型（用/分隔）
                if (type.includes('/')) {
                    const types = type.split('/');
                    return types.map(t => relationTypeMap[t] || t).join('/');
                }
                // 单个关系类型
                return relationTypeMap[type] || type;
            }

            const colors = {
                "KnowledgePoint": "#1f77b4",  // 蓝色
                "Course": "#ff7f0e",          // 橙色
                "DEFAULT": "#999999"          // 默认灰色
            };

            // 初始化SVG
            function initSvg() {
                const container = document.getElementById('graph-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // 清空现有SVG
                d3.select("#graph-container svg").remove();

                // 创建新SVG
                svg = d3.select("#graph-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

                // 创建缩放行为
                zoom = d3.zoom()
                    .scaleExtent([0.1, 4]) // 允许缩放的范围
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

                // 应用缩放
        svg.call(zoom);

                g = svg.append("g");

                // 添加箭头标记定义
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 25) // 增大值，让箭头远离节点
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#999");

                return g;
            }

            // 限制显示的节点数量
            function limitNodes(data, limit) {
                if (!data || !data.nodes || data.nodes.length <= limit) {
                    return data;
                }

                const limitedData = {
                    nodes: [],
                    relationships: []
                };

                // 优先保留课程节点
                const courseNodes = data.nodes.filter(node => node.label === 'Course');
                const otherNodes = data.nodes.filter(node => node.label !== 'Course');

                // 计算要保留的其他节点数量
                const otherNodeLimit = Math.max(0, limit - courseNodes.length);

                // 合并
                limitedData.nodes = [
                    ...courseNodes,
                    ...otherNodes.slice(0, otherNodeLimit)
                ];

                // 创建节点ID集合以便快速查找
                const nodeIds = new Set(limitedData.nodes.map(node => node.id));

                // 只保留连接已保留节点的关系
                limitedData.relationships = data.relationships.filter(rel =>
                    nodeIds.has(rel.source) && nodeIds.has(rel.target)
                );

                return limitedData;
            }

            // 更新图谱
            function updateGraph(data, preservePositions = false) {
                // 显示加载中
                document.getElementById('loading').style.display = 'block';

                // 保存原始数据
                originalData = data;

                // 限制节点数量
                const limitedData = limitNodes(data, nodeLimit);

                // 初始化SVG
                if (!g) {
                    g = initSvg();
                } else if (!preservePositions) {
                    g = initSvg();
                }

                // 更新数据
                nodes = limitedData.nodes;
                links = limitedData.relationships;

                // 如果保持位置，保存节点当前位置
                const nodePositions = {};
                if (preservePositions && nodeElements) {
                    nodeElements.each(function(d) {
                        nodePositions[d.id] = { x: d.x, y: d.y, fx: d.fx, fy: d.fy };
                    });
                }

                // 如果要保持位置，恢复节点的位置
                if (preservePositions) {
                    nodes.forEach(node => {
                        if (nodePositions[node.id]) {
                            node.x = nodePositions[node.id].x;
                            node.y = nodePositions[node.id].y;
                            node.fx = nodePositions[node.id].fx;
                            node.fy = nodePositions[node.id].fy;
                        }
                    });
                }

                // 停止之前的模拟
                if (simulation) {
                    simulation.stop();
                }

                // 获取容器尺寸，创建更大的初始布局区域
                const containerWidth = document.getElementById('graph-container').clientWidth;
                const containerHeight = document.getElementById('graph-container').clientHeight;
                const layoutWidth = Math.max(containerWidth, containerWidth * 1.5); // 扩大布局区域
                const layoutHeight = Math.max(containerHeight, containerHeight * 1.5);

                // 创建新的模拟，使用更强的力值使节点更分散
                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id)
                        .distance(d => {
                            // 根据节点类型调整链接距离
                            if (d.source.label === 'Course' || d.target.label === 'Course') {
                                return 180; // 课程节点之间的距离更大
                            }
                            return 150; // 默认距离更大
                        })
                    )
                    .force("charge", d3.forceManyBody()
                        .strength(d => {
                            // 根据节点类型调整排斥力
                            if (d.label === 'Course') {
                                return -1000; // 课程节点排斥力更强
                            }
                            return -800; // 默认排斥力也更强
                        })
                    )
                    .force("center", d3.forceCenter(layoutWidth / 2, layoutHeight / 2))
                    .force("x", d3.forceX(layoutWidth / 2).strength(0.05))
                    .force("y", d3.forceY(layoutHeight / 2).strength(0.05))
                    .force("collide", d3.forceCollide()
                        .radius(d => {
                            // 根据节点类型调整碰撞半径
                            if (d.label === 'Course') {
                                return 50; // 课程节点碰撞半径更大
                            }
                            return 40; // 默认碰撞半径
                        })
                        .strength(0.8) // 增加碰撞强度
                        .iterations(2) // 增加迭代次数以提高精度
                    );

                // 清除现有元素
                g.selectAll('.links').remove();
                g.selectAll('.nodes').remove();
                g.selectAll('.node-labels').remove();
                g.selectAll('.link-labels').remove();

                // 创建连接线
                linkElements = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(links)
                .enter().append("line")
                .attr("class", "link")
                    .attr("marker-end", "url(#arrowhead)");

            // 创建节点
                nodeElements = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("circle")
                    .data(nodes)
                    .enter().append("circle")
                .attr("class", d => "node" + (d.label === "Course" ? " course-node" : ""))
                    .attr("r", d => d.label === "Course" ? 18 : 12) // 增大节点半径
                    .attr("fill", d => colors[d.label] || colors.DEFAULT)
                .call(d3.drag()
                        .on("start", dragStarted)
                    .on("drag", dragged)
                        .on("end", dragEnded))
                    .on("click", showProperties)
                    .on("dblclick", fixNode);

                // 创建节点标签
                nodeLabels = g.append("g")
                    .attr("class", "node-labels")
                    .selectAll("text")
                    .data(nodes)
                    .enter().append("text")
                    .attr("class", "node-label")
                    .attr("dx", 15) // 增大标签与节点的距离
                    .attr("dy", ".35em")
                    .style("display", showLabels ? null : "none")
                    .text(d => d.name);

                // 创建连接线标签，过滤掉错误的"contains"关系
                linkLabels = g.append("g")
                    .attr("class", "link-labels")
                    .selectAll("g")  // 使用g元素作为容器而不是text
                    .data(getMergedLinkLabels(links).filter(d => {
                        // 过滤掉在课程节点上错误显示的"contains"关系
                        if (d.type === "包含" || d.type === "CONTAINS") {
                            const sourceNode = typeof d.source === 'object' ? d.source : nodes.find(n => n.id === d.source);
                            const targetNode = typeof d.target === 'object' ? d.target : nodes.find(n => n.id === d.target);

                            // 如果源节点和目标节点都是课程，则不显示"contains"关系
                            if (sourceNode && targetNode &&
                                sourceNode.label === "Course" && targetNode.label === "Course") {
                                return false;
                            }
                        }
                        return true;
                    }))  // 过滤关系数据
                    .enter().append("g")
                    .attr("class", "link-label-group");

                // 添加标签背景矩形
                linkLabels.append("rect")
                    .attr("class", "link-label-bg")
                    .attr("x", -12)
                    .attr("y", -8)
                    .attr("width", 24)
                    .attr("height", 16)
                    .style("display", showRelationLabels ? null : "none");

                // 添加标签文本
                linkLabels.append("text")
                    .attr("class", "link-label")
                .attr("text-anchor", "middle")
                    .attr("dy", ".35em")
                    .style("display", showRelationLabels ? null : "none")
                    .text(d => d.type);

                // 更新仿真
                simulation.on("tick", () => {
                    // 约束节点位置在扩展范围内，而不是视图范围
                    const containerWidth = document.getElementById('graph-container').clientWidth;
                    const containerHeight = document.getElementById('graph-container').clientHeight;
                    const extendedWidth = containerWidth * 1.5; // 扩展宽度
                    const extendedHeight = containerHeight * 1.5; // 扩展高度
                    const padding = 50; // 边缘填充增大

                    nodes.forEach(d => {
                        d.x = Math.max(padding, Math.min(extendedWidth - padding, d.x));
                        d.y = Math.max(padding, Math.min(extendedHeight - padding, d.y));
                    });

                    linkElements
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    nodeElements
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    nodeLabels
                        .attr("x", d => d.x)
                        .attr("y", d => d.y);

                    // 更新连接线标签位置
                    linkLabels
                        .attr("transform", d => {
                            // 计算连接线中点
                            const midX = (d.source.x + d.target.x) / 2;
                            const midY = (d.source.y + d.target.y) / 2;

                            // 对于同一对节点间的多个关系，添加偏移量
                            const dx = d.target.x - d.source.x;
                            const dy = d.target.y - d.source.y;
                            const angle = Math.atan2(dy, dx);

                            // 添加垂直偏移，避免标签直接放在线上
                            const offset = d.offsetY || 0;  // 使用预先计算的偏移
                            const perpX = -Math.sin(angle) * offset;
                            const perpY = Math.cos(angle) * offset;

                            return `translate(${midX + perpX}, ${midY + perpY})`;
                        });

                    // 更新连接线标签背景的大小
                    linkLabels.selectAll(".link-label-bg")
                        .attr("width", function() {
                            // 基于文本内容动态调整背景宽度
                            const textWidth = this.parentNode.querySelector("text").getComputedTextLength();
                            return textWidth + 16;  // 为中文文本增加更多填充
                        })
                        .attr("x", function() {
                            const textWidth = this.parentNode.querySelector("text").getComputedTextLength();
                            return -textWidth / 2 - 8;  // 居中对齐
                        })
                        .attr("y", -10)  // 调整背景垂直位置
                        .attr("height", 20);  // 增加背景高度
                });

                // 模拟结束时自动缩放以适应视图
                simulation.on("end", () => {
                    fitGraphToView();
                });

                // 设置较低的冷却速率使布局更稳定
                simulation.alpha(1).alphaDecay(0.02);

                if (isPaused) {
                    simulation.stop();
                }

                // 隐藏加载中
                document.getElementById('loading').style.display = 'none';
            }

            // 添加自动缩放以适应视图的函数
            function fitGraphToView() {
                if (!nodes.length) return;

                // 计算图形边界
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(d => {
                    minX = Math.min(minX, d.x);
                    minY = Math.min(minY, d.y);
                    maxX = Math.max(maxX, d.x);
                    maxY = Math.max(maxY, d.y);
                });

                // 添加填充
                const padding = 50;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;

                // 计算图形尺寸
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;

                // 获取容器尺寸
                const containerWidth = document.getElementById('graph-container').clientWidth;
                const containerHeight = document.getElementById('graph-container').clientHeight;

                // 计算缩放比例
                const scaleX = containerWidth / graphWidth;
                const scaleY = containerHeight / graphHeight;
                const scale = Math.min(scaleX, scaleY, 1); // 限制最大缩放为1

                // 计算平移量以使图形居中
                const translateX = (containerWidth - graphWidth * scale) / 2 - minX * scale;
                const translateY = (containerHeight - graphHeight * scale) / 2 - minY * scale;

                // 应用变换
                if (zoom) {
                    svg.transition()
                       .duration(750)
                       .call(zoom.transform, d3.zoomIdentity
                           .translate(translateX, translateY)
                           .scale(scale));
                }
            }

            // 固定节点位置
            function fixNode(event, d) {
                if (d.fx === null) {
                    // 固定节点位置
                    d.fx = d.x;
                    d.fy = d.y;
                    d3.select(this).classed("fixed", true);
                } else {
                    // 释放节点位置
                    d.fx = null;
                    d.fy = null;
                    d3.select(this).classed("fixed", false);
                }
            }

            // 高亮显示节点及其连接
            function highlightNode(nodeId) {
                if (!nodeElements || !linkElements || !nodeLabels) return;

                // 重置所有元素
                nodeElements.classed("highlighted", false);
                nodeLabels.classed("highlighted", false);

                if (!nodeId) return;

                // 高亮目标节点
                nodeElements.filter(d => d.id === nodeId).classed("highlighted", true);
                nodeLabels.filter(d => d.id === nodeId).classed("highlighted", true);

                // 高亮相关连接
                const relatedLinks = links.filter(link =>
                    link.source.id === nodeId || link.target.id === nodeId
                );

                // 获取相关节点ID
                const relatedNodeIds = new Set();
                relatedLinks.forEach(link => {
                    if (link.source.id === nodeId) {
                        relatedNodeIds.add(link.target.id);
                    } else {
                        relatedNodeIds.add(link.source.id);
                    }
                });

                // 高亮相关节点
                nodeElements.filter(d => relatedNodeIds.has(d.id)).classed("highlighted", true);
                nodeLabels.filter(d => relatedNodeIds.has(d.id)).classed("highlighted", true);
            }

            // 拖拽事件处理
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                // 不释放固定位置，拖动后节点保持在放置位置
                // d.fx = null;
                // d.fy = null;
            }

            // 显示属性面板
            function showProperties(event, d) {
                const panel = document.getElementById('properties-panel');
                const title = document.getElementById('properties-title');
                const content = document.getElementById('properties-content');

                title.textContent = d.name + " [" + d.label + "]";
                content.innerHTML = '';

                // 高亮选中的节点
                highlightNode(d.id);

                // 添加属性内容
                if (d.properties) {
                    const table = document.createElement('table');
                    table.className = 'table table-sm table-hover';

                    const tbody = document.createElement('tbody');

                    for (const [key, value] of Object.entries(d.properties)) {
                        const row = document.createElement('tr');

                        const keyCell = document.createElement('td');
                        keyCell.className = 'fw-bold';
                        keyCell.textContent = key;

                        const valueCell = document.createElement('td');

                        // 处理不同类型的值
                        if (Array.isArray(value)) {
                            if (value.length > 0) {
                                const list = document.createElement('ul');
                                list.className = 'mb-0 ps-3';

                                value.forEach(item => {
                                    const listItem = document.createElement('li');
                                    listItem.textContent = item;
                                    list.appendChild(listItem);
                                });

                                valueCell.appendChild(list);
                        } else {
                                valueCell.textContent = '无';
                            }
                        } else if (typeof value === 'object' && value !== null) {
                            valueCell.textContent = JSON.stringify(value);
                        } else {
                            valueCell.textContent = value;
                        }

                        row.appendChild(keyCell);
                        row.appendChild(valueCell);
                        tbody.appendChild(row);
                    }

                    table.appendChild(tbody);
                    content.appendChild(table);
                } else {
                    const noProps = document.createElement('p');
                    noProps.textContent = '没有可用的属性信息';
                    content.appendChild(noProps);
                }

                // 显示面板
                panel.style.display = 'block';
            }

            // 关闭属性面板
            document.getElementById('close-properties').addEventListener('click', function() {
                document.getElementById('properties-panel').style.display = 'none';
                // 清除高亮
                highlightNode(null);
            });

            // 执行查询
            function executeQuery(query) {
                // 显示加载中
                document.getElementById('loading').style.display = 'block';

                // 执行查询
                fetch(API_BASE_URL + '/Graphapps/query/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateGraph(data);
                    } else {
                        alert('查询错误: ' + data.error);
                        document.getElementById('loading').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('查询错误:', error);
                    alert('查询失败: ' + error);
                    document.getElementById('loading').style.display = 'none';
                });
            }

            // 修改稳定布局函数
            function stabilizeLayout() {
                if (!simulation) return;

                // 先暂停模拟
                simulation.stop();

                // 对所有节点进行固定
                nodes.forEach(node => {
                    node.fx = node.x;
                    node.fy = node.y;
                });

                // 更新节点样式
                nodeElements.classed("fixed", true);

                // 恢复模拟并快速冷却
                simulation.alpha(0.1).restart();
                setTimeout(() => {
                    simulation.stop();
                    // 自动缩放以适应视图
                    fitGraphToView();
                }, 300);
            }

            // 修改重置布局函数
            function resetLayout() {
                if (!simulation) return;

                // 释放所有固定节点
                nodes.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });

                // 更新节点样式
                nodeElements.classed("fixed", false);

                // 重启模拟并设置更低的冷却速率
                simulation.alpha(1).alphaDecay(0.02).restart();
                isPaused = false;
                document.getElementById('pause-btn').textContent = '暂停';

                // 添加延时自动缩放
                setTimeout(fitGraphToView, 2000);
            }

            // 暂停/恢复模拟
            function toggleSimulation() {
                if (!simulation) return;

                if (isPaused) {
                    // 恢复模拟
                    simulation.restart();
                    isPaused = false;
                    document.getElementById('pause-btn').textContent = '暂停';
                } else {
                    // 暂停模拟
                    simulation.stop();
                    isPaused = true;
                    document.getElementById('pause-btn').textContent = '恢复';
                }
            }

            // 绑定控制按钮事件
            document.getElementById('pause-btn').addEventListener('click', toggleSimulation);
            document.getElementById('reset-btn').addEventListener('click', resetLayout);

            // 添加适应视图按钮事件
            document.getElementById('stabilize-btn').addEventListener('click', () => {
                stabilizeLayout();
                setTimeout(fitGraphToView, 500);
            });

            // 绑定节点限制滑块事件
            document.getElementById('node-limit-slider').addEventListener('input', function() {
                nodeLimit = parseInt(this.value);
                document.getElementById('node-limit-value').textContent = nodeLimit;

                // 只有当有原始数据时才更新
                if (originalData) {
                    updateGraph(originalData, true); // 保持位置更新
                }
            });

            // 绑定标签显示开关
            document.getElementById('show-labels-switch').addEventListener('change', function() {
                showLabels = this.checked;
                if (nodeLabels) {
                    nodeLabels.style("display", showLabels ? null : "none");
                }
            });

            // 绑定关系标签显示开关
            document.getElementById('show-relation-labels-switch').addEventListener('change', function() {
                showRelationLabels = this.checked;
                if (linkLabels) {
                    linkLabels.selectAll("text, rect").style("display", showRelationLabels ? null : "none");
                }
            });

            // 绑定查询按钮事件
            document.getElementById('query-btn').addEventListener('click', function() {
                const query = document.getElementById('query-input').value.trim();
                if (query) {
                    executeQuery(query);
                }
            });

            // 绑定按回车键查询
            document.getElementById('query-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const query = this.value.trim();
                    if (query) {
                        executeQuery(query);
                    }
                }
            });

            // 绑定预设查询按钮事件
            document.querySelectorAll('.preset-query').forEach(button => {
                button.addEventListener('click', function() {
                    const query = this.getAttribute('data-query');
                    document.getElementById('query-input').value = query;
                    executeQuery(query);
                });
            });

            // 获取统计信息
            function loadStatistics() {
                console.log('loadStatistics函数被调用');
                const url = API_BASE_URL + '/Graphapps/statistics/';
                console.log('请求URL:', url);
                fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // 更新实体和关系计数
                        document.getElementById('entity-count').textContent = data.entity_count;
                        document.getElementById('relation-count').textContent = data.relation_count;

                        // 更新实体类型统计
                        const entityTypesContainer = document.getElementById('entity-types');
                        entityTypesContainer.innerHTML = '';

                        for (const [type, count] of Object.entries(data.entity_types)) {
                            const badge = document.createElement('span');
                            badge.className = 'badge rounded-pill';
                            badge.style.backgroundColor = colors[type] || colors.DEFAULT;
                            badge.style.margin = '2px';
                            badge.style.padding = '5px 10px';
                            badge.textContent = `${type}: ${count}`;
                            entityTypesContainer.appendChild(badge);
                        }

                        // 更新关系类型统计
                        const relationTypesContainer = document.getElementById('relation-types');
                        relationTypesContainer.innerHTML = '';

                        for (const [type, count] of Object.entries(data.relation_types)) {
                            const badge = document.createElement('span');
                            badge.className = 'badge rounded-pill bg-secondary';
                            badge.style.margin = '2px';
                            badge.style.padding = '5px 10px';
                            badge.textContent = `${type}: ${count}`;
                            relationTypesContainer.appendChild(badge);
                        }
                    }
                })
                .catch(error => {
                    console.error('获取统计信息失败:', error);
                });
            }

            // 加载初始图谱数据
            function loadInitialGraph() {
                // 显示加载中
                document.getElementById('loading').style.display = 'block';

                fetch(API_BASE_URL + '/Graphapps/get_graph_data/')
                .then(response => response.json())
                .then(data => {
                    // 如果有足够的数据，显示完整图谱，否则只显示部分
                    if (data.nodes.length > 0) {
                        if (data.nodes.length > 50) {
                            // 如果节点数太多，只显示课程
                            executeQuery('显示所有课程');
                        } else {
                            updateGraph(data);
                        }
                    } else {
                        document.getElementById('loading').style.display = 'none';
                        alert('没有可用的图谱数据');
                    }
                })
                .catch(error => {
                    console.error('加载图谱数据失败:', error);
                    document.getElementById('loading').style.display = 'none';
                    alert('加载图谱数据失败: ' + error);
                });
            }

            // 调试信息
            console.log('JavaScript开始执行...');
            console.log('API_BASE_URL:', API_BASE_URL);

            // 加载统计信息
            console.log('开始加载统计信息...');
            loadStatistics();

            // 加载初始图谱
            console.log('开始加载初始图谱...');
            loadInitialGraph();

            // 窗口大小改变时重新调整图谱
            window.addEventListener('resize', function() {
                if (simulation) {
                    const containerWidth = document.getElementById('graph-container').clientWidth;
                    const containerHeight = document.getElementById('graph-container').clientHeight;

                    // 更新SVG尺寸
                    svg.attr("width", containerWidth)
                       .attr("height", containerHeight);

                    // 更新力模型的中心
                    simulation.force("center", d3.forceCenter(containerWidth / 2, containerHeight / 2))
                              .alpha(0.3).restart();

                    // 重新适应视图
                    setTimeout(fitGraphToView, 500);
                }
            });

            // 更新getMergedLinkLabels函数，添加中文转换
            function getMergedLinkLabels(links) {
                // 用于存储节点对之间的关系
                const nodeRelations = new Map();

                // 遍历所有关系，按节点对分组
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

                    // 创建唯一键，确保源节点和目标节点顺序一致
                    const key = sourceId < targetId ?
                        `${sourceId}|${targetId}` :
                        `${targetId}|${sourceId}`;

                    if (!nodeRelations.has(key)) {
                        nodeRelations.set(key, {
                            source: link.source,
                            target: link.target,
                            types: [link.type],
                            count: 1
                        });
                    } else {
                        const rel = nodeRelations.get(key);
                        if (!rel.types.includes(link.type)) {
                            rel.types.push(link.type);
                        }
                        rel.count++;
                    }
                });

                // 将Map转换为数组并添加需要的属性
                const mergedLinks = Array.from(nodeRelations.values()).map((rel, index) => {
                    // 根据同一对节点间的关系数量计算垂直偏移
                    const baseOffset = 10; // 基础偏移量
                    let offsetY = 0;

                    // 如果有多个关系，计算垂直偏移
                    if (rel.count > 1) {
                        const relationText = rel.types.join('/');
                        rel.type = relationText;  // 使用斜杠连接多个关系类型

                        // 为不同的关系设置不同的偏移量
                        offsetY = baseOffset * (rel.count > 2 ? 2 : 1);
                    } else {
                        rel.type = rel.types[0];  // 只有一个关系时直接使用
                    }

                    // 将英文关系类型转换为中文
                    rel.type = translateRelationType(rel.type);

                    rel.offsetY = offsetY;
                    return rel;
                });

                return mergedLinks;
            }
        });
    </script>
</body>
</html>